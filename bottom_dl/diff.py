
'''
수치미분

경사법에서는 기울기 값을 기준으로 나아갈 방향을 정한다.

미분이란 ? 함축적으로 말하면, 한순간의 변화량을 얻는것이다.



'''


# def numerical_diff(f,x):
#     # h = 10e-50  #한 없이 0에 가까운 의미
#     h = 0.001  #델타 x가 0으로 수렴할 때
#
#     return (f(x+h) - f(x)) / h

'''

< 위 수치미분 함수에는 두가지 문제점이 있음 >
1) 반올림 오차 발생 가능성
    10e-50은 작은 값이다. 이런 형태는 0이 50개 있다는 의미인데,
    이 방식은 반올림 오차 문제를 일으킨다. 
    (컴퓨터에서 소수점 8자리 이하는 생략이 되어 계산결과 오차발생)
    
    ---> 10의 -4승 정도의 값 사용으로 대신사용
2) 함수 f의 차분
    이 구현에서는 진정한 미분 (x위치의 함수의 기울기)가 아닌
    (x+h) 와 x 사이의 기울기를 구해야 한다.
    따라서 수치 미분에는 오차가 포함된다. 줄이기 위해
    함수 f의 차분을 계산하여 사용한다.
    이것은 x를 중심으로 그 전후의 차분을 계산한다는 의미이다. (중앙차분, 중심차분)
       
'''


import numpy as np
import matplotlib.pylab as plt



def numerical_diff(f,x):
    # h = 10e-50  #한 없이 0에 가까운 의미
    h = 0.001  #델타 x가 0으로 수렴할 때
    a = (f(x+h) - f(x)) / h
    print(a)
    # return (f(x+h) - f(x)) / h

def func(x):
    return 0.01 * x ** 2 + 0.1 * x

x = np.arange(0.0, 20.0, 0.1)  # 0 에서 20까지 배영를 만드는데, 그 스텝을 0.1 간격으로 하여 배열을 생성한다.
y = func(x)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.plot(x,y)
plt.show()

'''
위처럼, 2차 함수의 그래프가 있을 때
x=5일때와
x=10일때의 이 함수의 미분을 계산

'''

numerical_diff(func,5)
numerical_diff(func,10)    # x=10 일때, 함수의 기울기



























